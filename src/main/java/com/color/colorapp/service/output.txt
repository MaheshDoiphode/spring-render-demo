package com.color.colorapp.service;

import com.color.colorapp.dto.BetPlacementDTO;
import com.color.colorapp.dto.RoundResultDTO;
import com.color.colorapp.entity.Round;
import com.color.colorapp.entity.User;
import com.color.colorapp.repository.RoundRepository;
import com.color.colorapp.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

@Service
public class FinanceService {

    @Autowired
    private RoundRepository roundRepository;

    @Autowired
    private UserRepository userRepository;

    public void closeBetting() {
        Round currentRound = getCurrentRound();
        if (currentRound != null && "ongoing".equals(currentRound.getStatus())) {
            currentRound.setStatus("betting closed");
            roundRepository.save(currentRound);
        }
    }

    @Transactional
    public void placeBet(BetPlacementDTO betDto) {
        User user = userRepository.findByUsername(betDto.getUsername());

        if (user == null || user.getWalletBalance() < betDto.getBetAmount()) {
            throw new RuntimeException("Invalid user or insufficient balance");
        }

        Round currentRound = getCurrentRound();
        if (currentRound == null || !"ongoing".equals(currentRound.getStatus())) {
            throw new RuntimeException("Betting is closed for the current round");
        }

        user.setWalletBalance(user.getWalletBalance() - betDto.getBetAmount());
        userRepository.save(user);

        Round.Bet bet = createBetFromDTO(betDto, user.getUserId());
        currentRound.getBets().add(bet);
        roundRepository.save(currentRound);
    }



    @Transactional
    public void declareRoundResult(RoundResultDTO resultDto) {
        Round round = roundRepository.findByRoundId(resultDto.getRoundId());
        if (round == null) {
            throw new RuntimeException("Round not found");
        }
        String winningColor = getWinningColor(resultDto.getWinningNumber());
        round.setResult(new Round.Result(resultDto.getWinningNumber(), winningColor));
        round.setStatus("completed");
        roundRepository.save(round);

        round.getBets().forEach(bet -> {
            if (isBetWinning(bet, resultDto.getWinningNumber())) {
                double payout = calculatePayout(bet);
                updateUserBalance(bet.getUserId(), payout);
            }
        });
    }

    private boolean isBetWinning(Round.Bet bet, int winningNumber) {
        if ("number".equals(bet.getBetType())) {
            return bet.getBetValue().equals(String.valueOf(winningNumber));
        } else {
            return isWinningColor(bet.getBetValue(), winningNumber);
        }
    }

    private boolean isWinningColor(String color, int number) {
        switch (color) {
            case "green":
                return number == 1 || number == 3 || number == 7 || number == 9;
            case "red":
                return number == 2 || number == 4 || number == 6 || number == 8 || number == 0;
            case "violet":
                return number == 0 || number == 5;
            default:
                return false;
        }
    }

    private double calculatePayout(Round.Bet bet) {
        double contractAmount = bet.getBetAmount() - 2; // Deducting service fee
        if ("number".equals(bet.getBetType())) {
            return contractAmount * 9; // SELECT NUMBER
        } else if ("green".equals(bet.getBetType()) || "red".equals(bet.getBetType())) {
            return contractAmount * 2; // JOIN GREEN or RED
        } else if ("violet".equals(bet.getBetType())) {
            return contractAmount * 4.5; // JOIN VIOLET
        }
        return 0;
    }

    private void updateUserBalance(Long userId, double payout) {
        User user = userRepository.findById(userId).orElse(null);
        if (user != null) {
            user.setWalletBalance(user.getWalletBalance() + payout);
            userRepository.save(user);
        }
    }












    private Round getCurrentRound() {
        String todayRoundIdPrefix = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        return roundRepository.findTopByRoundIdStartingWithOrderByRoundIdDesc(todayRoundIdPrefix);
    }

    private Round.Bet createBetFromDTO(BetPlacementDTO betDto, Long userId) {
        // Create Bet from DTO
        // ...
    }

    private String generateNewRoundId() {
        String todayRoundIdPrefix = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
        Round lastRound = roundRepository.findTopByRoundIdStartingWithOrderByRoundIdDesc(todayRoundIdPrefix);

        int nextRoundNumber = 1;
        if (lastRound != null) {
            String lastRoundNumberStr = lastRound.getRoundId().substring(8);
            int lastRoundNumber = Integer.parseInt(lastRoundNumberStr);
            nextRoundNumber = lastRoundNumber + 1;
        }

        return todayRoundIdPrefix + String.format("%02d", nextRoundNumber);
    }

    private String getWinningColor(int winningNumber) {
        switch (winningNumber) {
            case 0: return "purple";
            case 1:
            case 3:
            case 7:
            case 9: return "green";
            case 2:
            case 4:
            case 6:
            case 8: return "red";
            case 5: return "violet";
            default: return "";
        }
    }
}
package com.color.colorapp.service;

import com.color.colorapp.entity.Round;
import com.color.colorapp.repository.RoundRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Random;

@Service
public class GameService {

    @Autowired
    private RoundRepository roundRepository;

    @Autowired
    private FinanceService financeService;

    private final Random random = new Random();

    public void phase2() {
        // Close the current round and process results
        Round currentRound = getCurrentRound();
        if (currentRound != null && "ongoing".equals(currentRound.getStatus())) {
            currentRound.setStatus("betting closed");

            // Generate a random winning number
            int winningNumber = random.nextInt(10); // Random number between 0 and 9
            currentRound.getResult().setWinningNumber(winningNumber);

            roundRepository.save(currentRound);

            // Update balances and declare results
            financeService.declareRoundResult(currentRound);
        }
    }

    public void startNewBettingRound() {
        // Create a new round
        String newRoundId = generateNewRoundId();
        Round newRound = new Round();
        newRound.setRoundId(newRoundId);
        newRound.setStatus("ongoing");
        newRound.setTimestamp(Instant.now());
        newRound.setBets(new ArrayList<>());
        roundRepository.save(newRound);
    }

    private Round getCurrentRound() {
        // Logic to get the current round
        // ...
    }

    private String generateNewRoundId() {
        // Logic to generate a new round ID
        // ...
    }

    // Other methods and logic...
}
package com.color.colorapp.service;

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

@Service
public class RoundService {

    @Scheduled(fixedDelay = 180000) // 3 minutes
    public void processRound() {
        // Logic for processing the round
    }
}
package com.color.colorapp.service;

import com.color.colorapp.dto.UserLoginDTO;
import com.color.colorapp.dto.UserRegistrationDTO;
import com.color.colorapp.entity.User;
import com.color.colorapp.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;

@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;


    public User registerUser(UserRegistrationDTO registrationDTO) {
        User newUser = new User();
        newUser.setUsername(registrationDTO.getUsername());
        newUser.setEmail(registrationDTO.getEmail());
        newUser.setTextPassword(registrationDTO.getPassword());
        newUser.setDateOfBirth(registrationDTO.getDateOfBirth().atStartOfDay());
        newUser.setContactNumber(registrationDTO.getContactNumber());
        newUser.setRegistrationDate(LocalDateTime.now());

        return userRepository.save(newUser);
    }

    public boolean loginUser(UserLoginDTO loginDTO) {
        User user = userRepository.findByUsername(loginDTO.getUsername());
        return user != null && loginDTO.getPassword().equals(user.getTextPassword());
    }
}
